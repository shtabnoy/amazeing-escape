import MazeGraph from './MazeGraph'

describe('Test MST algorithm', () => {
  it('Graph 3 x 3', () => {
    const g = new MazeGraph()
    g.addEdge({ v1: '0,0', v2: '1,0', weight: 5 })
    g.addEdge({ v1: '0,0', v2: '0,1', weight: 2 })
    g.addEdge({ v1: '1,0', v2: '2,0', weight: 5 })
    g.addEdge({ v1: '1,0', v2: '1,1', weight: 1 })
    g.addEdge({ v1: '2,0', v2: '2,1', weight: 7 })
    g.addEdge({ v1: '0,1', v2: '1,1', weight: 3 })
    g.addEdge({ v1: '0,1', v2: '0,2', weight: 6 })
    g.addEdge({ v1: '1,1', v2: '2,1', weight: 7 })
    g.addEdge({ v1: '1,1', v2: '1,2', weight: 3 })
    g.addEdge({ v1: '2,1', v2: '2,2', weight: 3 })
    g.addEdge({ v1: '0,2', v2: '1,2', weight: 6 })
    g.addEdge({ v1: '1,2', v2: '2,2', weight: 7 })

    const result = g.mst()
    expect(result.edges[0].v1).toBe('0,0')
    expect(result.edges[0].v2).toBe('0,1')
    expect(result.edges[0].weight).toBe(2)
    expect(result.edges[1].v1).toBe('0,1')
    expect(result.edges[1].v2).toBe('1,1')
    expect(result.edges[1].weight).toBe(3)
    expect(result.edges[2].v1).toBe('1,0')
    expect(result.edges[2].v2).toBe('1,1')
    expect(result.edges[2].weight).toBe(1)
    expect(result.edges[3].v1).toBe('1,1')
    expect(result.edges[3].v2).toBe('1,2')
    expect(result.edges[3].weight).toBe(3)
    expect(result.edges[4].v1).toBe('1,0')
    expect(result.edges[4].v2).toBe('2,0')
    expect(result.edges[4].weight).toBe(5)
    expect(result.edges[5].v1).toBe('0,1')
    expect(result.edges[5].v2).toBe('0,2')
    expect(result.edges[5].weight).toBe(6)
    expect(result.edges[6].v1).toBe('1,1')
    expect(result.edges[6].v2).toBe('2,1')
    expect(result.edges[6].weight).toBe(7)
    expect(result.edges[7].v1).toBe('2,1')
    expect(result.edges[7].v2).toBe('2,2')
    expect(result.edges[7].weight).toBe(3)

    expect(g.edges.length).toBe(12)
    expect(result.edges.length).toBe(8)
  })

  it('Graph 4 x 4', () => {
    const g = new MazeGraph()
    g.addEdge({ v1: '0,0', v2: '1,0', weight: 7 })
    g.addEdge({ v1: '0,0', v2: '0,1', weight: 3 })
    g.addEdge({ v1: '1,0', v2: '2,0', weight: 5 })
    g.addEdge({ v1: '1,0', v2: '1,1', weight: 5 })
    g.addEdge({ v1: '2,0', v2: '3,0', weight: 1 })
    g.addEdge({ v1: '2,0', v2: '2,1', weight: 3 })
    g.addEdge({ v1: '3,0', v2: '3,1', weight: 4 })
    g.addEdge({ v1: '0,1', v2: '1,1', weight: 6 })
    g.addEdge({ v1: '0,1', v2: '0,2', weight: 4 })
    g.addEdge({ v1: '1,1', v2: '2,1', weight: 1 })
    g.addEdge({ v1: '1,1', v2: '1,2', weight: 7 })
    g.addEdge({ v1: '2,1', v2: '3,1', weight: 2 })
    g.addEdge({ v1: '2,1', v2: '2,2', weight: 2 })
    g.addEdge({ v1: '3,1', v2: '3,2', weight: 3 })
    g.addEdge({ v1: '0,2', v2: '1,2', weight: 6 })
    g.addEdge({ v1: '0,2', v2: '0,3', weight: 8 })
    g.addEdge({ v1: '1,2', v2: '2,2', weight: 3 })
    g.addEdge({ v1: '1,2', v2: '1,3', weight: 2 })
    g.addEdge({ v1: '2,2', v2: '3,2', weight: 8 })
    g.addEdge({ v1: '2,2', v2: '2,3', weight: 1 })
    g.addEdge({ v1: '3,2', v2: '3,3', weight: 5 })
    g.addEdge({ v1: '0,3', v2: '1,3', weight: 2 })
    g.addEdge({ v1: '1,3', v2: '2,3', weight: 5 })
    g.addEdge({ v1: '2,3', v2: '3,3', weight: 9 })

    const result = g.mst()
    expect(result.edges[0].v1).toBe('0,0')
    expect(result.edges[0].v2).toBe('0,1')
    expect(result.edges[0].weight).toBe(3)
    expect(result.edges[1].v1).toBe('0,1')
    expect(result.edges[1].v2).toBe('0,2')
    expect(result.edges[1].weight).toBe(4)
    expect(result.edges[2].v1).toBe('0,1')
    expect(result.edges[2].v2).toBe('1,1')
    expect(result.edges[2].weight).toBe(6)
    expect(result.edges[3].v1).toBe('1,1')
    expect(result.edges[3].v2).toBe('2,1')
    expect(result.edges[3].weight).toBe(1)
    expect(result.edges[4].v1).toBe('2,1')
    expect(result.edges[4].v2).toBe('3,1')
    expect(result.edges[4].weight).toBe(2)
    expect(result.edges[5].v1).toBe('2,1')
    expect(result.edges[5].v2).toBe('2,2')
    expect(result.edges[5].weight).toBe(2)
    expect(result.edges[6].v1).toBe('2,2')
    expect(result.edges[6].v2).toBe('2,3')
    expect(result.edges[6].weight).toBe(1)
    expect(result.edges[7].v1).toBe('2,0')
    expect(result.edges[7].v2).toBe('2,1')
    expect(result.edges[7].weight).toBe(3)
    expect(result.edges[8].v1).toBe('2,0')
    expect(result.edges[8].v2).toBe('3,0')
    expect(result.edges[8].weight).toBe(1)
    expect(result.edges[9].v1).toBe('3,1')
    expect(result.edges[9].v2).toBe('3,2')
    expect(result.edges[9].weight).toBe(3)
    expect(result.edges[10].v1).toBe('1,2')
    expect(result.edges[10].v2).toBe('2,2')
    expect(result.edges[10].weight).toBe(3)
    expect(result.edges[11].v1).toBe('1,2')
    expect(result.edges[11].v2).toBe('1,3')
    expect(result.edges[11].weight).toBe(2)
    expect(result.edges[12].v1).toBe('0,3')
    expect(result.edges[12].v2).toBe('1,3')
    expect(result.edges[12].weight).toBe(2)
    expect(result.edges[13].v1).toBe('1,0')
    expect(result.edges[13].v2).toBe('1,1')
    expect(result.edges[13].weight).toBe(5)
    expect(result.edges[14].v1).toBe('3,2')
    expect(result.edges[14].v2).toBe('3,3')
    expect(result.edges[14].weight).toBe(5)

    expect(g.edges.length).toBe(24)
    expect(result.edges.length).toBe(15)
  })
})
